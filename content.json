{"posts":[{"title":"FHE Made Simple - 1","text":"Put aside all the mathematical details about algebraic transforms like number-theoretic transforms (NTT) and Residue Number System (RNS) for an hour, and you will find FHE quite simple. RLWE CiphertextFor \\(a,s,e\\) are elements of some proper ring, a RLWE ciphertext encrypting \\(\\mu\\) is$$\\textrm{RLWE}_s(\\mu)=(a,as+\\mu+e)$$ Homomorphism of RLWE Plaintext Addition: \\(\\textrm{RLWE}_s(\\mu)\\oplus m = (a,as+\\mu+e+m)\\) Homomorphic Addition: \\(\\textrm{RLWE}_s(\\mu)+\\textrm{RLWE}_s(m) = (a+a^\\prime,as+\\mu+e+a^\\prime s+m+e^\\prime)\\) Plaintext Multiplication: \\(\\textrm{RLWE}_s(\\mu)\\cdot m = (am, ams+\\mu m+em)\\) Homomorphic Multiplication And KeyswitchWe take a backward method for the deduction of homomorphic multiplication, considering that$$\\mu\\cdot m\\approx (b-as)\\cdot(b^\\prime-a^\\prime s)$$where \\(b=as+\\mu+e,\\ b^\\prime=a^\\prime+m+e^\\prime\\). Also, considering the trivial RLWE ciphertexts, which are$$\\begin{align*}(0,b)=&amp;\\textrm{RLWE}_s(b)\\\\(a,0)=&amp;\\textrm{RLWE}_s(-as)\\end{align*}$$By applying the above euqations, we have$$\\begin{align*}&amp;\\textrm{RLWE}_s(\\mu\\cdot m)\\\\=&amp;\\textrm{RLWE}_s((b-as)(b^\\prime-a^\\prime s))\\\\=&amp;(0,bb^\\prime)+\\textrm{RLWE}_s(aa^\\prime s^2-ab^\\prime s-a^\\prime bs)\\\\=&amp;(0,bb^\\prime)+(ab^\\prime+a^\\prime b,0)+\\textrm{RLWE}_s(aa^\\prime s^2)\\\\=&amp;(ab^\\prime+a^\\prime b,bb^\\prime)+aa^\\prime\\cdot\\textrm{RLWE}_s(s^2)\\end{align*}$$ The ciphertext encrypting a non-trivial function of the secret key \\(s\\) is called a keyswitching key, which in this case is \\(\\textrm{RLWE}_s(s^2)\\). Also, we can rewrite the multiplication of a keyswitching key as a procedure called keyswitch: $$\\textrm{Keyswitch}_{s^2\\to s}(aa^\\prime)=aa^\\prime\\cdot\\textrm{RLWE}_s(s^2)$$ Therefore, homomorphic multiplication can then be rewritten as $$\\textrm{RLWE}_s(\\mu)\\otimes\\textrm{RLWE}_s(m)=(ab^\\prime+a^\\prime b,bb^\\prime)+\\textrm{Keyswitch}_{s^2\\to s}(aa^\\prime)$$ Noise Control And Decomposition of KeyswitchingThe term \\(e\\) in the RLWE ciphertext is usually called noise in a ciphertext. Usually its norm is bounded in fresh ciphertext. As homomorphic operations are performed over the ciphertext, the noise grows accordingly. To avoid decryption failure, the noise should be carefully maintained. In the case of keyswitching,$$\\textrm{Keyswitch}_{s^\\prime\\to s}(a)=a\\textrm{RLWE}_{s}(s^\\prime)$$The noise term in the keyswitching key is amplified by the norm of \\(a\\), which in most cases can be very large. Therefore, to maintain the noise level, we have to obtain the keyswitching result with multiplication of keyswitching key by low-norm terms. In FHE, a method called decomposition is introduced for noise maintaince:$$\\begin{align*}&amp;\\textrm{RLWE}_s(as^\\prime)\\\\=&amp;\\textrm{RLWE}_s(\\sum_ia_ig_is^\\prime)\\\\=&amp;\\sum_ia_i\\textrm{RLWE}_s(g_is^\\prime)\\end{align*}$$, where \\(a=\\sum_ia_ig_i\\) for some fixed \\(g_i\\) and \\(a_i\\) is norm-bounded. The set of \\(a_i\\) is called a decomposition of \\(a\\) and the set of \\(\\textrm{RLWE}_s(g_is^\\prime)\\) is then the keyswitching key under decomposition. The nosie-maintained keyswitching procedure is then$$\\textrm{Keyswitch}_{s^\\prime\\to s}(a)=\\sum_ia_i\\textrm{RLWE}_s(g_is^\\prime)$$A simplest decomposition is bit decomposition, where \\(g_i=2^i\\). In bit decomposition based keyswitch, each ciphertext in keyswitching key is multiplied by a bit and summed up together. Thus the magnitude of noise increase becames logarithmic to the norm of \\(a\\), which is much smaller than before. In the following blogs, we will introduce rns decomposition and digit decompostion. External ProductIn TFHE/FHEW-based schemes, external product is the basic operation to evaluate the homomorphic multiplication without key-dimension expansion (expand \\((1,s)\\) to \\((1,s,s^2)\\)) and relinearization. In fact, we have$$\\begin{align*}&amp;\\textrm{RLWE}_s(\\mu\\cdot m)\\\\=&amp;\\textrm{RLWE}_s((b-as)m)\\\\=&amp;\\textrm{RLWE}_s(bm)+\\textrm{RLWE}_s(-ams)\\\\=&amp;\\textrm{Keyswitch}_{m\\to s}(b)+\\textrm{Keyswtich}_{-ms\\to s}(a)\\end{align*}$$and the combination of keyswitching keys \\(\\textrm{RLWE}_s(mg_i),\\textrm{RLWE}_s(-msg_i)\\) is called RGSW. In some sense,$$\\textrm{External Product}=2\\times\\textrm{Keyswitch}$$and$$\\textrm{RGSW}=2\\times\\textrm{Keyswitching Key}$$ SummaryIn this blog, we introduced how a RLWE cipehrtext is encryped and homomorphic operations related to it. Futhermore, we introduced the homomorphic multiplication and keyswitching procedure. For better noise control, we introduced the decomposition of keyswitching. In the end, we introduced how to compose a external product in TFHE. A Simple ExerciseFor a distributive function \\(\\varphi\\), which means$$\\begin{align*}\\varphi(a\\pm b)=&amp;\\varphi(a)\\pm\\varphi(b)\\\\\\varphi(a\\cdot b)=&amp;\\varphi(a)\\cdot\\varphi(b)\\end{align*}$$can you deduce how to obtain \\(\\textrm{RLWE}_s(\\varphi(\\mu))\\) with \\(\\textrm{RLWE}_s(\\mu)\\) and some keyswitching key? A special case of such distributive function is the galois automorphism usually used in FHE:$$\\varphi_i(a(X))=a(X^{g^i})$$If you can deduce how to obtain \\(\\textrm{RLWE}_s(\\varphi(\\mu))\\), you may graduate in our mini-lecture “FHE Made Simple”! Solution Obviously, we have $$\\varphi(\\mu)\\approx\\varphi(b-as)=\\varphi(b)-\\varphi(a)\\varphi(s)$$ Note that \\(\\varphi(e)\\) should be bounded otherwise the above approximation will fail. Then we have$$\\textrm{RLWE}_s(\\varphi(\\mu))=\\textrm{RLWE}_s(\\varphi(b)-\\varphi(a)\\varphi(s))=(0,\\varphi(b))-\\textrm{Keyswitch}_{\\varphi(s)\\to s}(\\varphi(a))$$","link":"/2025/04/17/fhe-intro-1/"},{"title":"FHE Made Simple - 2","text":"Bootstrapping (TFHE/FHEW)Since boothstrapping for CKKS/BFV/BGV is highly associated with the algebraic structure of RLWE ciphertexts, before we dig into the mathematical background of the so-called “double-CRT” structure, we only discuss the bootstrapping for TFHE/FHEW. LWE DecryptionA LWE cipehrtext encrypts scalar \\(\\mu\\) with a vector \\(\\vec{a}\\) and a scalar \\(b\\) under key \\(\\vec{s}\\):$$b=\\vec{a}\\cdot\\vec{s}+\\mu+e$$The decryption of the LWE ciphertext \\(\\textrm{LWE}_{\\vec{s}}(\\mu)=(\\vec{a},b)\\) is then$$\\phi(\\textrm{LWE}_{\\vec{s}}(\\mu))=b-\\vec{a}\\cdot\\vec{s}=b-\\sum_ia_is_i$$ Homomorphic LWE DecryptionBootstrapping in FHE is a procedure of homomorphic decryption for ciphertexts. We will learn about how to extract LWE ciphertexts from RLWE. Hence, in this blog we omit the details of \\(\\textrm{RLWE}_{s^\\prime}(\\mu)\\mapsto\\textrm{LWE}_{\\vec{s}}(\\mu_0)\\) and the boostrapping in this blog contains only the procedure of \\(\\textrm{LWE}_{\\vec{s}}(\\mu)\\mapsto\\textrm{RLWE}_{s^\\prime}(X^{\\mu})\\). $$\\begin{align*}&amp;\\textrm{RLWE}_{s^\\prime}(X^\\mu)\\\\=&amp;\\textrm{RLWE}_{s^\\prime}(X^{b-\\sum_ia_is_i})\\\\=&amp;X^b\\cdot\\textrm{RLWE}_{s^\\prime}(\\prod_iX^{-a_is_i})\\end{align*}$$ In TFHE, we have \\(s_i\\in{0,1}\\). Then$$X^{-a_is_i}=\\begin{cases}1&amp;s_i=0\\\\X^{-a_i}&amp;s_i=1\\end{cases}=(X^{-a_i}-1)s_i+1$$ Then$$\\begin{align*}&amp;\\textrm{RLWE}_{s^\\prime}(X^\\mu)\\\\=&amp;X^b\\cdot\\textrm{RLWE}_{s^\\prime}(\\prod_iX^{-a_is_i})\\\\=&amp;X^b\\cdot\\textrm{RLWE}_{s^\\prime}(1)\\prod_i\\left((X^{-a_i}-1)\\textrm{RGSW}_{s^\\prime}(s_i)+\\textrm{RGSW}_{s^\\prime}(1)\\right)\\end{align*}$$The chaining multiplication of RLWE and RGSW is a series of external products introduced in previous blogs, where$$\\textrm{RLWE}_s(\\mu)\\boxdot\\textrm{RGSW}_s(m)=\\textrm{Keyswitch}_{m\\to s}(b)+\\textrm{Keyswitch}_{-ms\\to s}(a)$$Therefore, in step one we get \\(\\textrm{RLWE}_{s^\\prime}(m_0)=X^b\\cdot\\textrm{RLWE}_{s^\\prime}(1)\\boxdot\\left((X^{-a_0}-1)\\textrm{RGSW}_{s^\\prime}(s_0)+\\textrm{RGSW}_{s^\\prime}(1)\\right)\\) in step two we get \\(\\textrm{RLWE}_{s^\\prime}(m_1)=\\textrm{RLWE}_{s^\\prime}(m_0)\\boxdot\\left((X^{-a_1}-1)\\textrm{RGSW}_{s^\\prime}(s_1)+\\textrm{RGSW}_{s^\\prime}(1)\\right)\\) ……After all the iterations are executed, we get \\(\\textrm{RLWE}_{s^\\prime}(m_{n-1})=\\textrm{RLWE}_{s^\\prime}(X^{b-\\sum_ia_is_i})=\\textrm{RLWE}_{s^\\prime}(X^\\mu)\\). Since we were starting with the LWE ciphertext \\((\\vec{a},b)\\) with plaintext \\(\\mu\\) and RGSW encrypted key \\(\\vec{s}\\) and ending with a RLWE ciphertext \\(\\textrm{RLWE}_{s^\\prime}(X^\\mu)\\), the procedure is a boostrapping for the LWE ciphertext. An Alternative FormFor \\(\\textrm{RLWE}_{s^\\prime}(m_{i+1})=\\textrm{RLWE}_{s^\\prime}(m_i)\\boxdot\\left((X^{-a_i}-1)\\textrm{RGSW}_{s^\\prime}(s_i)+\\textrm{RGSW}_{s^\\prime}(1)\\right)\\), it is usually evaluated with an alternative form:$$\\textrm{RLWE}_{s^\\prime}(m_{i+1})=\\left(\\textrm{RLWE}_{s^\\prime}(m_i)(X^{-a_i}-1)\\right)\\boxdot\\textrm{RGSW}_{s^\\prime}(s_i)+\\textrm{RLWE}_{s^\\prime}(m_i)$$ Programmable Boostrapping (PBS)Assume that we have a function called “ExtractLWE”, which extracts a LWE ciphertext encrypting the constant coefficient of the plaintext encrypted by a RLWE ciphertext, namely$$\\textrm{ExtractLWE}_{s\\to \\vec{s^\\prime}}\\left(\\textrm{RLWE}_s(\\sum_iX^i\\mu_i)\\right)=\\textrm{LWE}_{\\vec{s^\\prime}}(\\mu_0)$$ Then consider the following bootstrapping procedure:$$\\begin{align*}&amp;\\textrm{LWE}_{\\vec{s}}(f(\\mu))\\\\=&amp;\\textrm{ExtractLWE}_{s^\\prime\\to\\vec{s}}\\left(\\textrm{RLWE}_{s^\\prime}(\\sum_iX^if(i)\\cdot X^{-\\mu})\\right)\\\\=&amp;\\textrm{ExtractLWE}_{s^\\prime\\to\\vec{s}}\\left(\\textrm{RLWE}_{s^\\prime}(\\sum_iX^if(i))\\cdot X^{-b}\\boxdot\\prod_i\\left((X^{a_i}-1)\\textrm{RGSW}_{s^\\prime}(s_i)+\\textrm{RGSW}_{s^\\prime}(1)\\right)\\right)\\\\=&amp;\\textrm{ExtractLWE}_{s^\\prime\\to\\vec{s}}\\left((0,\\sum_iX^if(i))\\cdot X^{-b}\\boxdot\\prod_i\\left((X^{a_i}-1)\\textrm{RGSW}_{s^\\prime}(s_i)+\\textrm{RGSW}_{s^\\prime}(1)\\right)\\right)\\end{align*}$$ In this way, we get \\(\\textrm{LWE}_{\\vec{s}}(f(\\mu))\\) from \\(\\textrm{LWE}_{\\vec{s}}(\\mu)\\) through bootstrapping, where \\(f\\) is an arbitrary function that can be encoded into coefficents of plaintext polynomial encrypted by RLWE ciphertexts. Such bootstrapping procedure is called a programmable boostrapping (PBS). \\((0,\\sum_iX^if(i))\\) is called a test vector of PBS \\(f(\\cdot)\\) is called a lookup table of PBS Some Notes The ExtractLWE is a bit different from the commonly used one since it is actually composed of two sub-programs: extracting a LWE with dimension equal to the polynomial degree of RLWE and keyswitching the extrated LWE to a LWE with smaller dimension. We haven’t discussed how to fit elements of LWE ciphertext into the exponent of the plaintext polynomial, which requires a scaling usually. Padding and noise estimation is a bit complicated. We will discuss those in more serious blogs. Happy diving in the FHE world!","link":"/2025/04/18/fhe-intro-2/"},{"title":"Modular Multiplication Designs","text":"In cryptography, modular multiplication is a fundamental arithmetic unit in calculation. Usually the cryptographic objects are based on data structures over finite fields. Thus, modular arithmetic operations are the atoms of cryptography. Modular addition/substraction is straightforward, but modular multiplication is a bit complicated. Though many literatures have discussed how to evaluate the modular multiplication with plain multiplication for general moduli, for faster modular multiplication, the number-theoretic properties of special moduli like NTT-friendly or low hamming-weight should be further utilized. In this blog, I will introduce some tricks on modular multiplication designs. A Tighter Parameter-selection Method for Barrett ModMulFor \\(2^{n-1}&lt;q&lt;2^n\\), a Barrett modmul can be written as $$z=xy\\mod{q}=xy-\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor\\cdot q$$ , where its key trick is to estimate the quotient \\(\\left\\lfloor\\frac{xy}{q}\\right\\rfloor\\) with \\(\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor\\) and \\(\\alpha,\\beta\\) are variable parameters for better estimation. The Classic EstimationAssume \\(0\\leq x,y&lt;2q\\) and we want to ensure that the result \\(z\\) locates in the same region. A classic estimation would be $$\\begin{align*}\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\leq&amp;\\frac{xy}{q}\\\\\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}&gt;&amp;\\frac{\\left(\\frac{xy}{2^{n+\\alpha}}-1\\right)\\cdot\\left(\\frac{2^{2n+\\alpha+\\beta}}{q}-1\\right)}{2^{n+\\beta}}\\\\=&amp;\\frac{xy}{q}-\\frac{2^{n+\\alpha}}{q}-\\frac{xy}{2^{2n+\\alpha+\\beta}}+\\frac{1}{2^{n+\\beta}}\\\\\\geq&amp;\\left\\lfloor\\frac{xy}{q}\\right\\rfloor-\\frac{1}{2}-\\frac{1}{2}+0=\\left\\lfloor\\frac{xy}{q}\\right\\rfloor-1\\end{align*}$$ Therefore, as long as \\(\\frac{2^{n+\\alpha}}{q}\\leq\\frac{1}{2},\\frac{xy}{2^{2n+\\alpha+\\beta}}\\leq\\frac{1}{2}\\), we have $$\\left\\lfloor\\frac{xy}{q}\\right\\rfloor\\geq\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor\\geq\\left\\lfloor\\frac{xy}{q}\\right\\rfloor-1$$and a step further,$$z=xy-\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor\\cdot q\\leq xy-(\\left\\lfloor\\frac{xy}{q}\\right\\rfloor-1)\\cdot q=(xy\\mod{q})+q&lt;2q$$ The parameter selection is then quite straightforward, take \\(\\alpha\\leq-2,\\alpha+\\beta\\geq3\\). A Tighter EstimationThe classic estimation simply applies the relation \\(x-1&lt;\\lfloor x\\rfloor\\leq x\\). We can estimate the quotient with another equivalence rather than the inequality set, which is$$\\left\\lfloor\\frac{x}{m}\\right\\rfloor=\\frac{x-[x]_m}{m}$$where \\([x]_m=x\\mod{m}\\in[0,m-1]\\). Therefore, the approximated quotient can be re-written as$$\\begin{align*}\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor=&amp;\\left\\lfloor\\frac{\\frac{xy-[xy]_{2^{n+\\alpha}}}{2^{n+\\alpha}}\\cdot\\frac{2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q}{q}}{2^{n+\\beta}}\\right\\rfloor\\\\=&amp;\\left\\lfloor\\frac{xy}{q}-\\frac{xy[2^{2n+\\alpha+\\beta}]_q}{2^{2n+\\alpha+\\beta}q}-\\frac{[xy]_{2^{n+\\beta}}\\cdot(2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q)}{2^{2n+\\alpha+\\beta}q}\\right\\rfloor\\\\=&amp;\\left\\lfloor\\frac{xy}{q}\\right\\rfloor+\\left\\lfloor\\frac{[xy]_q}{q}-\\frac{xy[2^{2n+\\alpha+\\beta}]_q}{2^{2n+\\alpha+\\beta}q}-\\frac{[xy]_{2^{n+\\beta}}\\cdot(2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q)}{2^{2n+\\alpha+\\beta}q}\\right\\rfloor\\\\=&amp;\\left\\lfloor\\frac{xy}{q}\\right\\rfloor+\\left\\lfloor\\frac{[xy]_q2^{2n+\\alpha+\\beta}-xy[2^{2n+\\alpha+\\beta}]_q-[xy]_{2^{n+\\beta}}\\cdot(2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q)}{2^{2n+\\alpha+\\beta}q}\\right\\rfloor\\end{align*}$$ Therefore, one need only to satisfy the constraint$$C(\\alpha,\\beta)=\\min_{x,y}{\\frac{[xy]_q2^{2n+\\alpha+\\beta}-xy[2^{2n+\\alpha+\\beta}]_q-[xy]_{2^{n+\\beta}}\\cdot(2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q)}{2^{2n+\\alpha+\\beta}q}}\\geq -1$$","link":"/2025/04/09/modmul%20designs/"},{"title":"Zhen Gu","text":"","link":"/2025/04/01/zhengu/"}],"tags":[{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"fhe","slug":"fhe","link":"/tags/fhe/"},{"name":"arithmetic","slug":"arithmetic","link":"/tags/arithmetic/"},{"name":"hardware","slug":"hardware","link":"/tags/hardware/"}],"categories":[{"name":"tech blogs","slug":"tech-blogs","link":"/categories/tech-blogs/"},{"name":"home","slug":"home","link":"/categories/home/"}],"pages":[]}