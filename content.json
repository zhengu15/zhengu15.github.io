{"posts":[{"title":"Modular Multiplication Designs","text":"In cryptography, modular multiplication is a fundamental arithmetic unit in calculation. Usually the cryptographic objects are based on data structures over finite fields. Thus, modular arithmetic operations are the atoms of cryptography. Modular addition/substraction is straightforward, but modular multiplication is a bit complicated. Though many literatures have discussed how to evaluate the modular multiplication with plain multiplication for general moduli, for faster modular multiplication, the number-theoretic properties of special moduli like NTT-friendly or low hamming-weight should be further utilized. In this blog, I will introduce some tricks on modular multiplication designs. A Tighter Parameter-selection Method for Barrett ModMulFor \\(2^{n-1}&lt;q&lt;2^n\\), a Barrett modmul can be written as $$z=xy\\mod{q}=xy-\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor\\cdot q$$ , where its key trick is to estimate the quotient \\(\\left\\lfloor\\frac{xy}{q}\\right\\rfloor\\) with \\(\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor\\) and \\(\\alpha,\\beta\\) are variable parameters for better estimation. The Classic EstimationAssume \\(0\\leq x,y&lt;2q\\) and we want to ensure that the result \\(z\\) locates in the same region. A classic estimation would be $$\\begin{align*}\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\leq&amp;\\frac{xy}{q}\\\\\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}&gt;&amp;\\frac{\\left(\\frac{xy}{2^{n+\\alpha}}-1\\right)\\cdot\\left(\\frac{2^{2n+\\alpha+\\beta}}{q}-1\\right)}{2^{n+\\beta}}\\\\=&amp;\\frac{xy}{q}-\\frac{2^{n+\\alpha}}{q}-\\frac{xy}{2^{2n+\\alpha+\\beta}}+\\frac{1}{2^{n+\\beta}}\\\\\\geq&amp;\\left\\lfloor\\frac{xy}{q}\\right\\rfloor-\\frac{1}{2}-\\frac{1}{2}+0=\\left\\lfloor\\frac{xy}{q}\\right\\rfloor-1\\end{align*}$$ Therefore, as long as \\(\\frac{2^{n+\\alpha}}{q}\\leq\\frac{1}{2},\\frac{xy}{2^{2n+\\alpha+\\beta}}\\leq\\frac{1}{2}\\), we have $$\\left\\lfloor\\frac{xy}{q}\\right\\rfloor\\geq\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor\\geq\\left\\lfloor\\frac{xy}{q}\\right\\rfloor-1$$and a step further,$$z=xy-\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor\\cdot q\\leq xy-(\\left\\lfloor\\frac{xy}{q}\\right\\rfloor-1)\\cdot q=(xy\\mod{q})+q&lt;2q$$ The parameter selection is then quite straightforward, take \\(\\alpha\\leq-2,\\alpha+\\beta\\geq3\\). A Tighter EstimationThe classic estimation simply applies the relation \\(x-1&lt;\\lfloor x\\rfloor\\leq x\\). We can estimate the quotient with another equivalence rather than the inequality set, which is$$\\left\\lfloor\\frac{x}{m}\\right\\rfloor=\\frac{x-[x]_m}{m}$$where \\([x]_m=x\\mod{m}\\in[0,m-1]\\). Therefore, the approximated quotient can be re-written as$$\\begin{align*}\\left\\lfloor\\frac{\\left\\lfloor\\frac{xy}{2^{n+\\alpha}}\\right\\rfloor\\cdot\\left\\lfloor\\frac{2^{2n+\\alpha+\\beta}}{q}\\right\\rfloor}{2^{n+\\beta}}\\right\\rfloor=&amp;\\left\\lfloor\\frac{\\frac{xy-[xy]_{2^{n+\\alpha}}}{2^{n+\\alpha}}\\cdot\\frac{2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q}{q}}{2^{n+\\beta}}\\right\\rfloor\\\\=&amp;\\left\\lfloor\\frac{xy}{q}-\\frac{xy[2^{2n+\\alpha+\\beta}]_q}{2^{2n+\\alpha+\\beta}q}-\\frac{[xy]_{2^{n+\\beta}}\\cdot(2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q)}{2^{2n+\\alpha+\\beta}q}\\right\\rfloor\\\\=&amp;\\left\\lfloor\\frac{xy}{q}\\right\\rfloor+\\left\\lfloor\\frac{[xy]_q}{q}-\\frac{xy[2^{2n+\\alpha+\\beta}]_q}{2^{2n+\\alpha+\\beta}q}-\\frac{[xy]_{2^{n+\\beta}}\\cdot(2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q)}{2^{2n+\\alpha+\\beta}q}\\right\\rfloor\\\\=&amp;\\left\\lfloor\\frac{xy}{q}\\right\\rfloor+\\left\\lfloor\\frac{[xy]_q2^{2n+\\alpha+\\beta}-xy[2^{2n+\\alpha+\\beta}]_q-[xy]_{2^{n+\\beta}}\\cdot(2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q)}{2^{2n+\\alpha+\\beta}q}\\right\\rfloor\\end{align*}$$ Therefore, one need only to satisfy the constraint$$C(\\alpha,\\beta)=\\min_{x,y}{\\frac{[xy]_q2^{2n+\\alpha+\\beta}-xy[2^{2n+\\alpha+\\beta}]_q-[xy]_{2^{n+\\beta}}\\cdot(2^{2n+\\alpha+\\beta}-[2^{2n+\\alpha+\\beta}]_q)}{2^{2n+\\alpha+\\beta}q}}\\geq -1$$","link":"/2025/04/09/modmul%20designs/"},{"title":"Zhen Gu","text":"","link":"/2025/04/01/zhengu/"},{"title":"FHE Made Simple","text":"Put aside all the mathematical details about algebraic transforms like number-theoretic transforms (NTT) and Residue Number System (RNS) for an hour, and you will find FHE quite simple. RLWE CiphertextFor \\(a,s,e\\) are elements of some proper ring, a RLWE ciphertext encrypting \\(\\mu\\) is$$\\textrm{RLWE}_s(\\mu)=(a,as+\\mu+e)$$ Homomorphism of RLWE Plaintext Addition: \\(\\textrm{RLWE}_s(\\mu)\\oplus m = (a,as+\\mu+e+m)\\) Homomorphic Addition: \\(\\textrm{RLWE}_s(\\mu)+\\textrm{RLWE}_s(m) = (a+a^\\prime,as+\\mu+e+a^\\prime s+m+e^\\prime)\\) Plaintext Multiplication: \\(\\textrm{RLWE}_s(\\mu)\\cdot m = (am, ams+\\mu m+em)\\) Homomorphic Multiplication And KeyswitchWe take a backward method for the deduction of homomorphic multiplication, considering that$$\\mu\\cdot m\\approx (b-as)\\cdot(b^\\prime-a^\\prime s)$$where \\(b=as+\\mu+e,\\ b^\\prime=a^\\prime+m+e^\\prime\\). Also, considering the trivial RLWE ciphertexts, which are$$\\begin{align*}(0,b)=&amp;\\textrm{RLWE}_s(b)\\\\(a,0)=&amp;\\textrm{RLWE}_s(-as)\\end{align*}$$By applying the above euqations, we have$$\\begin{align*}&amp;\\textrm{RLWE}_s(\\mu\\cdot m)\\\\=&amp;\\textrm{RLWE}_s((b-as)(b^\\prime-a^\\prime s))\\\\=&amp;(0,bb^\\prime)+\\textrm{RLWE}_s(aa^\\prime s^2-ab^\\prime s-a^\\prime bs)\\\\=&amp;(0,bb^\\prime)+(ab^\\prime+a^\\prime b,0)+\\textrm{RLWE}_s(aa^\\prime s^2)\\\\=&amp;(ab^\\prime+a^\\prime b,bb^\\prime)+aa^\\prime\\cdot\\textrm{RLWE}_s(s^2)\\end{align*}$$ The ciphertext encrypting a non-trivial function of the secret key \\(s\\) is called a keyswitching key, which in this case is \\(\\textrm{RLWE}_s(s^2)\\). Also, we can rewrite the multiplication of a keyswitching key as a procedure called keyswitch: $$\\textrm{Keyswitch}_{s^2\\to s}(aa^\\prime)=aa^\\prime\\cdot\\textrm{RLWE}_s(s^2)$$ Therefore, homomorphic multiplication can then be rewritten as $$\\textrm{RLWE}_s(\\mu)\\otimes\\textrm{RLWE}_s(m)=(ab^\\prime+a^\\prime b,bb^\\prime)+\\textrm{Keyswitch}_{s^2\\to s}(aa^\\prime)$$ Noise Control And Decomposition of KeyswitchingThe term \\(e\\) in the RLWE ciphertext is usually called noise in a ciphertext. Usually its norm is bounded in fresh ciphertext. As homomorphic operations are performed over the ciphertext, the noise grows accordingly. To avoid decryption failure, the noise should be carefully maintained. In the case of keyswitching,$$\\textrm{Keyswitch}_{s^\\prime\\to s}(a)=a\\textrm{RLWE}_{s}(s^\\prime)$$The noise term in the keyswitching key is amplified by the norm of \\(a\\), which in most cases can be very large. Therefore, to maintain the noise level, we have to obtain the keyswitching result with multiplication of keyswitching key by low-norm terms. In FHE, a method called decomposition is introduced for noise maintaince:$$\\begin{align*}&amp;\\textrm{RLWE}_s(as^\\prime)\\\\=&amp;\\textrm{RLWE}_s(\\sum_ia_ig_is^\\prime)\\\\=&amp;\\sum_ia_i\\textrm{RLWE}_s(g_is^\\prime)\\end{align*}$$, where \\(a=\\sum_ia_ig_i\\) for some fixed \\(g_i\\) and \\(a_i\\) is norm-bounded. The set of \\(a_i\\) is called a decomposition of \\(a\\) and the set of \\(\\textrm{RLWE}_s(g_is^\\prime)\\) is then the keyswitching key under decomposition. The nosie-maintained keyswitching procedure is then$$\\textrm{Keyswitch}_{s^\\prime\\to s}(a)=\\sum_ia_i\\textrm{RLWE}_s(g_is^\\prime)$$A simplest decomposition is bit decomposition, where \\(g_i=2^i\\). In bit decomposition based keyswitch, each ciphertext in keyswitching key is multiplied by a bit and summed up together. Thus the magnitude of noise increase becames logarithmic to the norm of \\(a\\), which is much smaller than before. In the following blogs, we will introduce rns decomposition and digit decompostion. External ProductIn TFHE/FHEW-based schemes, external product is the basic operation to evaluate the homomorphic multiplication without key-dimension expansion (expand \\((1,s)\\) to \\((1,s,s^2)\\)) and relinearization. In fact, we have$$\\begin{align*}&amp;\\textrm{RLWE}_s(\\mu\\cdot m)\\\\=&amp;\\textrm{RLWE}_s((b-as)m)\\\\=&amp;\\textrm{RLWE}_s(bm)+\\textrm{RLWE}_s(-ams)\\\\=&amp;\\textrm{Keyswitch}_{m\\to s}(b)+\\textrm{Keyswtich}_{-ms\\to s}(a)\\end{align*}$$and the combination of keyswitching keys \\(\\textrm{RLWE}_s(mg_i),\\textrm{RLWE}_s(-msg_i)\\) is called RGSW. In some sense,$$\\textrm{External Product}=2\\times\\textrm{Keyswitch}$$and$$\\textrm{RGSW}=2\\times\\textrm{Keyswitching Key}$$ SummaryIn this blog, we introduced how a RLWE cipehrtext is encryped and homomorphic operations related to it. Futhermore, we introduced the homomorphic multiplication and keyswitching procedure. For better noise control, we introduced the decomposition of keyswitching. In the end, we introduced how to compose a external product in TFHE. A Simple ExerciseFor a distributive function \\(\\varphi\\), which means$$\\begin{align*}\\varphi(a\\pm b)=&amp;\\varphi(a)\\pm\\varphi(b)\\\\\\varphi(a\\cdot b)=&amp;\\varphi(a)\\cdot\\varphi(b)\\end{align*}$$can you deduce how to obtain \\(\\textrm{RLWE}_s(\\varphi(\\mu))\\) with \\(\\textrm{RLWE}_s(\\mu)\\) and some keyswitching key? A special case of such distributive function is the galois automorphism usually used in FHE:$$\\varphi_i(a(X))=a(X^{g^i})$$If you can deduce how to obtain \\(\\textrm{RLWE}_s(\\varphi(\\mu))\\), you may graduate in our mini-lecture “FHE Made Simple”! Solution Obviously, we have $$\\varphi(\\mu)\\approx\\varphi(b-as)=\\varphi(b)-\\varphi(a)\\varphi(s)$$ Note that \\(\\varphi(e)\\) should be bounded otherwise the above approximation will fail. Then we have$$\\textrm{RLWE}_s(\\varphi(\\mu))=\\textrm{RLWE}_s(\\varphi(b)-\\varphi(a)\\varphi(s))=(0,\\varphi(b))-\\textrm{Keyswitch}_{\\varphi(s)\\to s}(\\varphi(a))$$","link":"/2025/04/17/fhe-intro-1/"}],"tags":[{"name":"arithmetic","slug":"arithmetic","link":"/tags/arithmetic/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"hardware","slug":"hardware","link":"/tags/hardware/"},{"name":"fhe","slug":"fhe","link":"/tags/fhe/"}],"categories":[{"name":"tech blogs","slug":"tech-blogs","link":"/categories/tech-blogs/"},{"name":"home","slug":"home","link":"/categories/home/"}],"pages":[]}